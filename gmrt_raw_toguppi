#!/datax/scratch/AMITY_INDIA/avi/github/casadev/bin/python3.8

from collections import defaultdict
import numpy as np
from pathlib import Path
from baseband import guppi
import sys
from os import path
import time
import argparse
import astropy.units as u

def gmrt_guppi(rawfile, npol=2, header=None, chunk=None, samples_per_frame=4096, nchan=1):
    """
    To read gmrt raw voltages file of GWB to convert to guppi raw

    :USAGE:
    --------
    $ gmrt_raw_toguppi [-h] [-f FILENAME] [-c CHUNK] [-hdr HEADER] [-hf HEADER_FILE] [-hfo HEADER_FILE_OUTPUT]

    To read gmrt raw voltages file of GWB to convert to guppi raw

    optional arguments:
    -h, --help            show this help message and exit
    -f FILENAME, --filename FILENAME
                        Input filename for conversion to guppiraw.
    -c CHUNK, --chunk CHUNK
                        Input chunk size to read the desired chunk of byte.
    -hdr HEADER, --header HEADER
                        Input header to inject to the raw file.
    -hf HEADER_FILE, --header-file HEADER_FILE
                        Input header from path to inject to the raw file.
    -hfo HEADER_FILE_OUTPUT, --header-file-output HEADER_FILE_OUTPUT
                        output header from path to inject to the raw file.
    
    NOTE
    ----- 
    imaginary data is not being read as documentation(https://baseband.readthedocs.io/en/stable/api/baseband.guppi.open.html#baseband.guppi.open):
    For GUPPI, complex data is only allowed when nchan > 1.
    """
    b=time.time()
    if path.isfile(rawfile):
        rawname=Path(rawfile).stem
        if header is None:
            header = {#'CHAN_BW':-100,
        'TBIN':1, #provide sample rate in astropy.units * Hz
        'TELESCOP':'GMRT',
        'NPOL':npol,
        'NCHAN':nchan,
        'OBSERVER':'Vishal Gajjar',
            'STT_IMJD':58132,
            'STT_SMJD':51093,
        'NBITS':8}
        print(f'selected parameters: rawfile={rawfile}, npol={npol}, header={header}, chunk={chunk}, samples_per_frame={samples_per_frame}, nchan={nchan}')
        print(f'copying file:{rawfile}')
        if chunk is None:
            npcm_data=np.memmap(rawfile, dtype='<i1', mode='r' )#,shape=(4096,))
        else:
            npcm_data=np.memmap(rawfile, dtype='<i1', mode='r', shape=(chunk,))
        print(f'copied file :{time.time()-b}')
        #npcm_data.flush()
        #number_of_frames = totalsamples/samples_per_frame
        #shape = (samples_per_frame,number_of_frames)
        #npcm_data.flush()
        
        real1_d =npcm_data # 0,2,4 indexed
        im_d=np.zeros(np.shape(real1_d))
        
        resd=np.array([real1_d,im_d], dtype='<i1').transpose()
        
        guppifile=rawname+''
        print(f'writing file stem: {guppifile}')
        #fgh = guppi.open(guppifile+'_guppi.{file_nr:04d}.raw', 'ws', frames_per_file=1180013,
        fgh = guppi.open(guppifile+'_guppi.0000.raw', 'ws',
                    samples_per_frame=samples_per_frame, nchan=nchan,
                    #npol=npol, #sample_rate=2.0E+08*u.Hz,
                    **header)
        print(f'data shape: {np.shape(resd)}')
        fgh.write(resd)


# -------------- when you have [p1r1,p1i1,p2r1,p2i1...]


        # im_d = npcm_data[1::2] # even indexed

        # ## pol1, pol2 = npcm_data[::2], npcm_data[1::2] # if no imaginary is in the bytes
        # #pol1, pol2 = real_d[::2], real_d[1::2]
        # ## pol1, pol2 = npcm_data[::2][::2], npcm_data[::2][1::2]
        
        # pol1_real = real_d[::2]
        # pol2_real = real_d[1::2]
        
        # pol1_im=im_d[1::2]
        # pol2_im=im_d[::2] # if you need imaginary and real
        # pol1=pol1_real+pol1_im*1j
        # pol2=pol2_real+pol2_im*1j
        
        
        # #resd=np.array([pol1,pol2]).transpose()
        # guppifile=rawname+''
        # print(f'writing file stem: {guppifile}')
        # #fgh = guppi.open(guppifile+'_guppi.{file_nr:04d}.raw', 'ws', frames_per_file=1180013,
        # fgh = guppi.open(guppifile+'_guppi.0000.raw', 'ws',
        #             samples_per_frame=samples_per_frame, nchan=nchan,
        #             #npol=npol, #sample_rate=2.0E+08*u.Hz,
        #             **header)
        # #fgh.write(resd)
        # resd=np.array([[pol1,pol2],[pol1,pol2]] , dtype='complex64').transpose()
        # print(f'data shape: {np.shape(resd)}')
        # #fgh.write(np.array([npcm_data[::2][::2], npcm_data[::2][1::2]]).transpose())
        # fgh.write(resd)
        #fgh.write(np.array(npcm_data))
        print(f'file writing completed: {time.time()-b}')
        fgh.close()
        return f'file created: {guppifile}'
    else:
        return f'file does not exist : {rawfile}'


def header_from_file(hfile):
    with open(hfile) as hf:
        header = defaultdict(list)
        hfr=hf.read().splitlines()
        for i in range(len(hfr)):
            if '#' in hfr[i]:
                continue
            elif '=' in hfr[i]:
                hdrk,hdrv=hfr[i].split('=')
                try:
                    hdrv=int(hdrv)
                except:
                    try:
                        hdrv=float(hdrv)
                    except:
                        hdrv=str(hdrv)
                #print(f'{hdrk}={hdrv}')#, type(hdrv))
                header[hdrk]=hdrv
                #header[hdrk]=hdrv
    return header


def wheader(header, filepath='binary_header'):
    #p=[f"{k} = '{header[k]}'".ljust(80," ") for k in header if (header[k] and isinstance(header[k], str))]
    #p.extend(f"{k} = {header[k]}".ljust(80," ")  for k in header if (header[k] and not isinstance(header[k], str) or (header[k]==0)))
    p=[]
    for k in header: 
        if (header[k] and not isinstance(header[k], str) or (header[k]==0)):
            kad = f'{k}'.ljust(8," ")
            vad = f'{header[k]}'.rjust(21," ")
            p.append(f"{kad} = {vad}".ljust(80," "))
        if (header[k] and isinstance(header[k], str)):
            vad = f'{k}'.ljust(8," ")
            kad = f'{header[k]}'.ljust(8," ")
            p.append(f"{vad} = '{kad}'".ljust(80," "))
    
    p.append(f'END'.ljust(80," "))
    agg = ''
    for pr in p:
        agg+=pr
    ##
    with open(filepath, 'wb') as bf:
        bf.write(bytes(agg, encoding='ascii'))
        
    return agg, filepath

parser = argparse.ArgumentParser(description="""To read gmrt raw voltages file of GWB to convert to guppi raw
""")
parser.add_argument('-f', '--filename',type=str,help="Input filename for conversion to guppiraw.", required=False)
parser.add_argument('-c', '--chunk',type=int,help="Input chunk size to read the desired chunk of byte.", required=False)
parser.add_argument('-hdr', '--header', type=str, help="Input header to inject to the raw file.", required=False)
parser.add_argument('-hf', '--header-file', type=str, help="Input header from path to inject to the raw file.", required=False)
parser.add_argument('-hfo', '--header-file-output', type=str, help="output header from path to inject to the raw file.", required=False)
args=parser.parse_args()

def cli():
    rawfile=args.filename
    chunk=args.chunk
    hlist=args.header_file
    hfo=args.header_file_output
    hdrin=args.header
    header = defaultdict(list)
    if hdrin:
        print(hdrin)
        hdrin=str(hdrin)
        hdrdict=hdrin.split(',')
        for i in range(len(hdrdict)):
            if '=' in hdrdict[i]:
                hdrk,hdrv=hdrdict[i].split('=')
                try:
                    hdrv=int(hdrv)
                except:
                    try:
                        hdrv=float(hdrv)
                    except:
                        hdrv=str(hdrv)
                print(f'{hdrk}={hdrv}', type(hdrv))
                header[hdrk]=hdrv
    elif hlist:
        header=header_from_file(hlist)
        if hfo:
            printable_header, hfile_out=wheader(header,filepath=hfo)
            print(f'header file created: {hfile_out}')
    if rawfile:
        print(gmrt_guppi(rawfile=rawfile, chunk=chunk, header=header))

if __name__=='__main__':
    cli()